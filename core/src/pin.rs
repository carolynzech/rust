//! Types that pin data to a location in memory.
//!
//! It is sometimes useful to be able to rely upon a certain value not being able to *move*,
//! in the sense that its address in memory cannot change. This is useful specifically when there
//! is a *pointer* that is pointing at that value. The ability to rely on this guarantee that
//! the *value a pointer is pointing at* (its *pointee*) will not move is necessary to implement
//! things like self-referential structs, as moving an object with pointers that are meant to
//! point into that struct's own data would cause those pointers to no longer be valid (they
//! would still be pointing at the struct's old location in memory).
//!
//! "Pinning" allows us to put a value *which is being pointed at* by some pointer `Ptr` into a state
//! that prevents safe code from *moving* the *pointee* value. In this way, we can allow [`unsafe`] code
//! to rely on the pointer not having its pointee moved out from under it.
//! 
//! The rest of this documentation is intended to be the source of truth for users of [`Pin<Ptr>`]
//! in unsafe code; users of [`Pin<Ptr>`] in safe code do not need to read it in detail.
//!
//! There are several sections to this documentation:
//!
//! * [What is "*moving*"?][what-is-moving]
//! * [What is "pinning"?][what-is-pinning]
//! * [Examples of types that have address-sensitive states][address-sensitive-examples]
//!   * [Self-referential struct][self-ref]
//!   * [Intrusive, doubly-linked list][linked-list]
//! * [Subtle Details][subtle-details]
//!
//! # What is "*moving*"?
//! [what-is-moving]: self#what-is-moving
//!
//! When we say a value is *moved*, we mean that the compiler copies, byte-for-byte, the
//! value from one location to another. A move is mechanically identical to [`Copy`]ing
//! a value and discarding the old version of the data, thus making the moved-from value
//! inaccessible. Whenever we write *move* in italics, we mean this precise definition of
//! moving a value. 
//!
//! All values in Rust are trivially *moveable*. This means that the address at which a value is
//! located is not necessarily stable in between borrows, and that the compiler is allowed to
//! *move* it to a new address without running any code to notify that value that its address
//! has changed.
//!
//! ```
//! #[derive(Default)]
//! struct AddrTracker(Option<usize>);
//!
//! impl AddrTracker {
//!     fn check_for_move(&mut self) {
//!         let current_addr = self as *mut Self as usize;
//!         match self.0 {
//!             None => self.0 = Some(addr),
//!             Some(prev_addr) => assert_eq!(prev_addr, current_addr),
//!         }
//!     }
//! }
//! 
//! fn take_and_return(tracker: AddrTracker) -> AddrTracker {
//!     tracker
//! }
//!
//! let mut tracker = AddrTracker::default();
//! tracker.check_for_move();
//! 
//! let mut tracker = take_and_return(tracker);
//! 
//! // May panic!
//! // tracker.check_for_move();
//! ```
//! 
//! Although the compiler will not insert moves where no semantic move has occurred, there
//! are many places where a value *may* be moved. For example, when passed into a function.
//! In this sense, Rust does not guarantee that `check_for_move()` will
//! never panic, because the compiler is permitted to *move* `tracker` to enable
//! optimizations like pass-by-value.
//!
//! Common smart-pointer types such as [`Box<T>`] and [`&mut T`] allow removing and replacing the
//! values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`]. Putting
//! `tracker` behind a pointer isn't enough on its own to ensure that its address does not change.
//!
//! # What is "pinning"?
//! [what-is-pinning]: #what-is-pinning
//!
//! `Pin` wraps a pointer type `P`, but removes the ability to actually obtain a `P` from it in safe
//! code. By disallowing access to the type behind the pointer, `Pin` prevents us from using
//! operations like [`mem::swap`] to *move* out of the pointer.
//!
//! ## Address-sensitive types
//!
//! One noteworthy example of types which require `Pin` for correctness are the [`Future`]` types
//! generated by the compiler for `async fn`s.
//!
//! For these types, any value which lives "across" an `.await` point is stored in the state
//! machine, including values which borrow from other variables in the `async fn`. *Moving* the
//! [`Future`] in between calls to [`poll`] would invalidate these pointers, leaving the next call
//! to [`poll`] with dangling references!
//!
//! Such types are *address-sensitive*: they incorporate the address of `self` into an
//! operation. These types usually follow a common lifecycle:
//!
//! 1. A value is created which can be freely moved around.
//!     * e.g. calling an async function
//! 2. An operation causes the value to depend on its own address using [`unsafe`].
//!     * e.g. calling [`poll`] for the first time on the produced [`Future`]
//! 3. Further [`unsafe`] operations assume that its address is stable.
//!     * e.g. subsequent calls to [`poll`]
//! 4. The value is destroyed, undoing its address-sensitivity.
//!     * e.g. [`drop`]ping the [`Future`]
//!
//! [`Pin<P>`] helps us implement steps (2) and (3) safely.
//!
//! ## `Pin` and pointers
//!
//! [`Pin<P>`] can wrap any pointer type, forming a promise that the pointee will not be *moved*.
//! This promise must be upheld by [`unsafe`] code which interacts with the [`Pin<P>`] so that
//! [`unsafe`] code can place the pointee in an address-sensitive state that will not be broken
//! by a *move*. Operations on an address-sensitive type accept an argument like
//! <code>[Pin]<[`&mut T`]></code> or <code>[Pin]<[`Box<T>`]></code> to indicate this contract to
//! the caller.
//!
//! Since [`Pin<P>`] can wrap any pointer type, it interacts with
//! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where [`P: Deref`][Deref] is a
//! "`P`-style pointer" to a pinned [`P::Target`][Target] – so, a
//! <code>[Pin]<[`Box<T>`]></code> is an owned pointer to a pinned `T`, and a
//! <code>[Pin]<[`Rc<T>`]></code> is a reference-counted pointer to a pinned `T`.
//!
//! [`Pin<P>`] requires that implementations of [`Deref`] and [`DerefMut`] return a pointer to
//! pinned data when they are called on a pinned pointer and do not *move* out of their `self`
//! parameter. It is unsound for [`unsafe`] code to wrap such "evil" pointers; see
//! [`Pin<P>::new_unchecked`] for details.
//!
//! Pinning does not require any compiler "magic", only a specific contract between the library API
//! and its users. This differs from e.g. [`UnsafeCell`] which changes the semantics of a program's
//! compiled output. A [`Pin<P>`] is a handle to a value which does not allow moving the value out,
//! but Rust still considers all values themselves to be moveable with e.g. [`mem::swap`].
//!
//! These guarantees are necessary to make our `AddrTracker` example work. If any code
//! sees a <code>[Pin]<&mut AddrTracker></code>, it can safely assume that it will *always* see
//! [the same object][address-stability] for the same address (for the lifetime of
//! the pointee). If we had written `check_for_move` above to accept a
//! <code>[Pin]<[`&mut Self`]></code> instead, multiple calls to it *cannot* panic:
//!
//! ```
//! # use std::pin::Pin;
//! # #[derive(Default)]
//! # struct AddrTracker(usize);
//! impl AddrTracker {
//!     fn check_for_move(self: Pin<&mut Self>) {
//!         unsafe {
//!             let unpinned = Pin::get_unchecked_mut(self);
//!             let addr = unpinned as *mut Self as usize;
//!             match unpinned.0 {
//!                 0 => unpinned.0 = addr,
//!                 x => assert_eq!(x, addr),
//!             }
//!         }
//!     }
//! }
//!
//! let mut tracker = Box::pin(AddrTracker::default());
//! tracker.as_mut().check_for_move();
//! tracker.as_mut().check_for_move();
//! ```
//!
//! [As discussed below][drop-guarantee], this has consequences for running
//! destructors of pinned memory, too.
//!
//! ## [`Unpin`]
//!
//! The vast majority of Rust types are not address-sensitive; these types
//! implement the [`Unpin`] auto-trait, which cancels the restrictive effects of
//! [`Pin<P>`]. When [`T: Unpin`][Unpin], <code>[Pin]<[`Box<T>`]></code> and
//! [`Box<T>`] function identically, as do <code>[Pin]<[`&mut T`]></code> and
//! [`&mut T`].
//!
//! This includes all of the basic types, like [`bool`], [`i32`], and [`&T`][&],
//! as well as any other type consisting only of those types. You can opt out of
//! [`Unpin`] via the [`PhantomPinned`] marker type.
//!
//! Pinning and [`Unpin`] only affect the pointee type [`P::Target`][Target], not the pointer type
//! `P` itself. For example, whether or not [`Box<T>`] is [`Unpin`] has no effect on the behavior of
//! <code>[Pin]<[`Box<T>`]></code> because `T` is the pointee type.
//!
//! # Examples of address-sensitive types
//! [address-sensitive-examples]: #examples-of-address-sensitive-types
//!
//! ## Self-referential struct
//! [self-ref]: #a-self-referential-struct
//! [`Unmovable`]: #a-self-referential-struct
//!
//! Self-referential structs are the simplest kind of address-sensitive type.
//!
//! It is often useful for a struct to hold a pointer back into itself, which
//! allows the program to efficiently track subsections of the struct.
//! Below, the `slice` field is a pointer into the `data` field, which
//! we could imagine being used to track a sliding window of `data` in parser
//! code.
//!
//! As mentioned before, this pattern is used extensively by compiler-generated
//! [`Future`]s.
//!
//! ```rust
//! use std::pin::Pin;
//! use std::marker::PhantomPinned;
//! use std::ptr::NonNull;
//!
//! /// This is a self-referential struct because `self.slice` points into `self.data`.
//! struct Unmovable {
//!     /// Backing buffer.
//!     data: [u8; 64],
//!     /// Points at `self.data` which we know is itself non-null. Raw pointer because we can't do
//!     /// this with a normal reference.
//!     slice: NonNull<[u8]>,
//!     /// Suppress `Unpin` so that this cannot be moved out of a `Pin` once constructed.
//!     _pin: PhantomPinned,
//! }
//!
//! impl Unmovable {
//!     /// Create a new `Unmovable`.
//!     ///
//!     /// To ensure the data doesn't move we place it on the heap behind a pointer which can
//!     /// itself be moved.
//!     fn new() -> Pin<Box<Self>> {
//!         let res = Unmovable {
//!             data: [0; 64],
//!             // We only create the pointer once the data is in place
//!             // otherwise it will have already moved before we even started.
//!             slice: NonNull::from(&mut []),
//!             _pin: PhantomPinned,
//!         };
//!         let mut boxed = Box::pin(res);
//!
//!         let slice = NonNull::from(&boxed.data);
//!         // We know this is safe, because modifying a field doesn't move the whole
//!         // struct.
//!         unsafe {
//!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);
//!             Pin::get_unchecked_mut(mut_ref).slice = slice;
//!         }
//!         boxed
//!     }
//! }
//!
//! let unmoved = Unmovable::new();
//! // The pointer should point to the correct location, so long as the struct hasn't moved.
//! // Meanwhile, we are free to move the pointer around.
//! # #[allow(unused_mut)]
//! let mut still_unmoved = unmoved;
//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));
//!
//! // Since our type doesn't implement `Unpin`, this will fail to compile.
//! // We cannot mutably dereference a `Pin` to `!Unpin` data.
//! // let mut new_unmoved = Unmovable::new();
//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);
//! ```
//!
//! ## Intrusive, doubly-linked list
//! [linked-list]: #an-intrusive-doubly-linked-list
//! [`Node`]: #an-intrusive-doubly-linked-list
//! [`List`]: #an-intrusive-doubly-linked-list
//! [`&mut Node`]: #an-intrusive-doubly-linked-list
//! [`List::append`]: #an-intrusive-doubly-linked-list
//!
//!
//! In an intrusive doubly-linked list, the collection does not actually allocate the memory for the
//! nodes itself. Allocation is controlled by the clients, and nodes can live on a stack frame
//! that lives shorter than the collection does provided the nodes are removed from the
//! collection before returning.
//!
//! Every node has pointers to its predecessor and successor in the list. Nodes can only be
//! added when they are pinned, because moving the nodes around would invalidate the pointers.
//! The [`Drop`] implementation of a linked list node will patch the pointers of its predecessor
//! and successor to remove itself from the list; not doing so would result in a use-after-free when
//! the list went to refer to the destroyed node.
//!
//! ```rust
//! use std::marker::PhantomPinned;
//! use std::pin::Pin;
//! use std::ptr;
//!
//! /// The list itself is Unpin, because it doesn't actually hold any data that cannot move
//! /// (although, if nodes held a reference back into it, it would need to be `!Unpin`).
//! ///
//! /// Holds the first and last nodes in the list; they are either both null or both non-null.
//! struct List {
//!     start: *mut Node,
//!     end: *mut Node,
//! }
//!
//! impl List {
//!     fn new() -> Self {
//!         Self { start: ptr::null_mut(), end: ptr::null_mut() }
//!     }
//!
//!     /// Appends the pinned `node` to the end of the list.
//!     ///
//!     /// For this function to be correct, we need two guarantees:
//!     ///
//!     ///   1. `node` never moves again so that our raw pointers to it are always valid
//!     ///   2. If a `Node`'s memory would be re-used, its destructor gets run first, removing the
//!     ///      would-be-dangling references from the list.
//!     fn append(&mut self, node: Pin<&mut Node>) {
//!         // We could make `List: !Unpin` and track *which* list owns a node if we were fancier.
//!         assert!(
//!             node.pred.is_null() && node.succ.is_null(),
//!             "Node must not already be in another list.",
//!         );
//!
//!         unsafe {
//!             // Unpin the `&mut Node`. This is safe, because we're not actually
//!             // moving the value, only modifying the pointers inside. This
//!             // reference cannot escape this function.
//!             let node = Pin::get_unchecked_mut(node);
//!
//!             // Rearrange the pointers as appropriate for a doubly-linked list.
//!             if self.start.is_null() {
//!                 self.start = node;
//!             } else {
//!                 (*self.end).succ = node;
//!                 node.pred = self.end;
//!             }
//!             self.end = node;
//!         }
//!     }
//!
//!     /// Allocates a node on the heap and appends it to the end of the list.
//!     fn append_boxed(&mut self) -> Pin<Box<Node>> {
//!         let mut node = Box::pin(Node {
//!             pred: ptr::null_mut(),
//!             succ: ptr::null_mut(),
//!             data: Data::new(),
//!             _pin: PhantomPinned,
//!         });
//!         self.append(node.as_mut());
//!         node
//!     }
//! }
//!
//! # struct Data;
//! # impl Data { fn new() -> Self { Data } }
//! struct Node {
//!     pred: *mut Node,
//!     succ: *mut Node,
//!     data: Data,
//!     /// `Node: Unpin` because `List` expects `Pin`ned pointers to them to remain in place.
//!     _pin: PhantomPinned,
//! }
//!
<<<<<<< HEAD
//! This can never cause a problem in safe code because implementing a type that
//! relies on pinning requires unsafe code, but be aware that deciding to make
//! use of pinning in your type (for example by implementing some operation on
//! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your
//! [`Drop`][Drop] implementation as well: if an element of your type could have been pinned,
//! you must treat [`Drop`][Drop] as implicitly taking <code>[Pin]<[&mut] Self></code>.
=======
//! impl Drop for Node {
//!     /// Remove pointers to `self`, allowing reuse of this memory without clients seeing garbage.
//!     fn drop(&mut self) {
//!         if self.pred.is_null() || self.succ.is_null() {
//!             // Not included: code to remove `self` if it is the head or tail of the list.
//!             return;
//!         }
>>>>>>> 389e1e2452d (Rewrite `Pin<P>` docs to clarify guarantees and uses)
//!
//!         unsafe {
//!             (*self.pred).succ = self.succ;
//!             (*self.succ).pred = self.pred;
//!         }
//!     }
//! }
//! ```
//!
//! For this to work, a [`drop`-related guarantee][drop-guarantee] is required. If a node could
//! be deallocated or otherwise invalidated without calling [`drop`], the pointers into it from its
//! neighboring elements would become invalid, which would break the data structure.
//!
//! [`List`] itself is *not* address-sensitive.
//!
//! # Subtle details
//! [subtle-details]: #subtle-details
//!
//! [`List::append`] above relies on both of [`Pin<P>`]'s guarantees:
//!
//! 1.  *Address Stability.* If [`unsafe`] code witnesses any [`p: Pin<P>`][Pin] at any time then
//!     it may assume that `p.as_ref().get_ref() as *const _` will remain valid, pointing to the
//!     same object until the end of that object's lifetime.
//! 2.  *Notice of Destruction.* If `x: T` was ever reachable through any [`Pin<P>`] type, its
//!     destructor must be run (until it either returns or panics) before `x`'s storage can be
//!     overwritten. The "until further notice" in (1) includes this mandatory destruction. This is
//!     often called the "[`Drop`] guarantee".
//!
//! ## Address Stability
//! [address-stability]: #address-stability
//!
//! The precise meaning of "address stability" is subtle, because "the same object" is not well-defined.
//! It is easiest to reason about it in terms of *visibility of mutations*. If [`unsafe`] code mutates
//! through a [`Pin<P>`], all code that stashed a raw pointer into it will see the mutation. In other
//! words, [`unsafe`] code can rely on the same value in memory being updated by all uses of a particular
//! [`Pin<P>`], not to mention that those stashed raw pointers remain valid in the first place.
//!
//! When a [`List`] stores a [`Node`], it needs to assume that appending a second node will mutate the
//! first node, so that later, when the first node is removed, it knows that its predecessor is the
//! second node.
//!
//! When writing generic code, it's not possible to know what [`unsafe`] code has recorded about the
//! pointee's address, so it must be very careful to observe this invariant. Thankfully, most of this
//! is already enforced by the [`Pin<P>`] API, so only [`unsafe`] code needs to worry about this.
//!
//! ## Notice of Destruction
//! [drop-guarantee]: #notice-of-destruction
//!
//! There needs to be a way for a pinned value to notify any [`unsafe`] code that recorded its address
//! that it is about to be destroyed, so that they can remove its address from their data structures.
//! Thus, in any situation where it would be safe to overwrite a pinned value, the destructor must
//! be called beforehand.
//!
//! The most common storage-reuse situation is when a value on the stack is destroyed as part of a
//! function return, or when heap storage is freed. In both cases, the destructor gets run for us
//! by Rust. However, for heap storage, [`unsafe`] code must make sure to call [`ptr::drop_in_place`]
//! if it wishes to use the [`std::alloc`] APIs manually.
//!
//! However, reuse can happen even if not storage is de-allocated. For example, when a [`Some`]
//! is overwritten by [`None`] using [`ptr::write`], or when [`Vec::set_len`] is used to manually
//! "kill" some elements of a vector. Both of these cases are somewhat contrived, but it is crucial
//! to remember to run destructors of [`Pin`]ned data. As a corollary, the following code can *never* be
//! made safe:
//!
//! ```rust
//! # use std::mem::ManuallyDrop;
//! # use std::pin::Pin;
//! # struct Type;
//! let mut pinned = Box::pin(ManuallyDrop::new(Type));
//! let inner = unsafe {
//!     Pin::map_unchecked_mut(Pin::as_mut(&mut pinned), |x| &mut *x)
//! };
//! ```
//!
//! Because [`mem::ManuallyDrop`] inhibits the destructor of `Type`, it won't get run, even though
//! normally [`Box<T>`] drops the `T` before freeing the storage.
//!
//! Of course, *leaking* memory is still fine: [`mem::forget`]ing a [`Box<T>`]
//! prevents its storage from ever getting re-used, so destruction notice does not apply.
//!
//! # Implementing an address-sensitive type.
//!
//! This section goes into detail on important considerations for implementing your own
//! address-sensitive types, which are different from merely using [`Pin<P>`] in a generic
//! way.
//!
//! ## Implementing [`Drop`] for an `!Unpin` Type
//! [drop-impl]: #implementing-drop-for-an-unpin-type
//!
//! The [`drop`] function takes [`&mut self`], but this is called *even if your
//! type was previously pinned*! Implementing [`Drop`] requires some care, since it is as if
//! the compiler automatically called [`Pin::get_unchecked_mut`].
//! This can never cause a problem in safe code, because implementing an address-sensitive type
//! requires unsafe code (such as the [linked list above][linked-list]).
//!
//! Beware that deciding to make your type address-sensitive by implementing some operation on
//! <code>[Pin]<[&Self][&]></code> or <code>[Pin]<[`&mut Self`]></code> has consequences for your
//! [`Drop`] implementation as well: if an element of your type could have been pinned,
//! you must treat [`Drop`] as implicitly taking <code>[Pin]<[`&mut Self`]></code>.
//!
//! You should implement [`Drop`] as follows:
//!
//! ```rust,no_run
//! # use std::pin::Pin;
//! # struct Type;
//! impl Drop for Type {
//!     fn drop(&mut self) {
//!         // `new_unchecked` is okay because we know this value is never used
//!         // again after being dropped.
//!         inner_drop(unsafe { Pin::new_unchecked(self)});
//!         fn inner_drop(this: Pin<&mut Type>) {
//!             // Actual drop code goes here.
//!         }
//!     }
//! }
//! ```
//!
//! The function `inner_drop` has the type that [`drop`] *should* have. This makes sure that
//! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.
//!
//! Moreover, if your type is [`#[repr(packed)]`][packed], the compiler will automatically
//! move fields around to be able to drop them. It might even do
//! that for fields that happen to be sufficiently aligned. As a consequence, you cannot use
//! pinning with a [`#[repr(packed)]`][packed] type.
//!
//! ## "Assigning" pinned data
//!
//! Although in general it is not valid to swap data through a [`Pin<P>`], or assign from
//! a [`Pin<P>`], for the same reason that a *move* is invalid, there is no particular reason
//! to disallow doing it with specialized functions, as long as they know how to update all
//! uses of the pinned address (and any other `unsafe`-assumed invariants). For [`Unmovable`],
//! we could write
//!
//! ```
//! # use std::pin::Pin;
//! # use std::marker::PhantomPinned;
//! # use std::ptr::NonNull;
//! # struct Unmovable {
//! #     data: [u8; 64],
//! #     slice: NonNull<[u8]>,
//! #     _pin: PhantomPinned,
//! # }
//! #
//! impl Unmovable {
//!     // Copies the contents of `src` into `self`, fixing up the self-pointer
//!     // in the process.
//!     fn assign(self: Pin<&mut Self>, src: Pin<&mut Self>) {
//!         unsafe {
//!             let unpinned_self = Pin::into_inner_unchecked(self);
//!             let unpinned_src = Pin::into_inner_unchecked(src);
//!             *unpinned_self = Self {
//!                 data: unpinned_src.data,
//!                 slice: NonNull::from(&mut []),
//!                 _pin: PhantomPinned,
//!             };
//!
//!             let data_ptr = unpinned_src.data.as_ptr() as *const u8;
//!             let slice_ptr = unpinned_src.slice.as_ptr() as *const u8;
//!             let offset = slice_ptr.offset_from(data_ptr) as usize;
//!             let len = (*unpinned_src.slice.as_ptr()).len();
//!
//!             unpinned_self.slice = NonNull::from(&mut unpinned_self.data[offset..offset+len]);
//!         }
//!     }
//! }
//! ```
//!
//! Even though we can't have the compiler do the assignment for us, it's possible to write
//! such specialized functions for types that might need it. It wouldn't be too difficult
//! implement such a function for the [`Node`], either.
//!
//! Note that it _is_ possible to assign through a [`Pin<P>`] by way of [`Pin::set()`]. This does
//! not violate any guarantees, since it will run the destructor of the pointee before assigning
//! the new value.
//!
//! ## Projections and Structural Pinning
//!
//! With ordinary structs, it is natural that we want to add *projection* methods
//! that select one of the fields:
//!
//! ```
//! # struct Field;
//! struct Struct {
//!     field: Field,
//!     // ...
//! }
//!
//! impl Struct {
//!     fn field(&mut self) -> &mut Field { &mut self.field }
//! }
//! ```
//!
//! When working with address-sensitive types, it's not obvious what the signature of these
//! functions should be. If `field` takes <code>self: [Pin]<[&mut Struct][&mut]></code>, should it return
//! [`&mut Field`] or <code>[Pin]<[`&mut Field`]></code>? This question also arises with `enum`s and
//! wrapper types like [`Vec<T>`], [`Box<T>`], and [`RefCell<T>`]. (This question
//! applies just as well to shared references, but we'll examine the more common case
//! of mutable references for illustration).
//!
//! It turns out that it's up to the author of `Struct` to decide which type the projection
//! should produce. The choice must be *consistent* though: each field should only ever
//! be projected as pinned or unpinned; both together will likely be unsound!
//!
//! As the author of a data structure, you get to decide for each field whether pinning
//! "propagates" to this field or not. Pinning that propagates is also called "structural",
//! because it follows the structure of the type.
//!
//! The choice of whether to pin depends on how the type is being used. If unsafe code
//! that consumes <code>[Pin]\<[&mut Struct][&mut]></code> also needs to take note of
//! the address of the field itself, it may be evidence that that field is structurally
//! pinned. Unfortunately, there are no hard-and-fast rules.
//!
//! ### When pinning *is not* structural for `field`...
//!
//! While counter-intuitive, it's actually the easier choice: if a <code>[Pin]<[`&mut Field`]></code>
//! is never created, nothing can go wrong! So, if you decide that some field does not have
//! structural pinning, all you have to ensure is that you never create a pinned reference to that field.
//!
//! Fields without structural pinning may have a projection method that turns
//! <code>[Pin]<[&mut Struct][&mut]></code> into [`&mut Field`]:
//!
//! ```rust,no_run
//! # use std::pin::Pin;
//! # type Field = i32;
//! # struct Struct { field: Field }
//! impl Struct {
//!     fn field(self: Pin<&mut Self>) -> &mut Field {
//!         // This is okay because `field` is never considered pinned.
//!         unsafe { &mut self.get_unchecked_mut().field }
//!     }
//! }
//! ```
//!
//! You may also <code>impl [Unpin] for Struct {}</code> *even if* the type of `field`
//! is not [`Unpin`]. What that type thinks about pinning is not relevant
//! when no <code>[Pin]<[`&mut Field`]></code> is ever created.
//!
//! For example, the `data` field of [`Node`] does *not* need
//! to be structurally pinned, because neither [`List`] nor
//! [`Node`] assume anything about it.
//!
//! ### When pinning *is* structural for `field`...
//!
//! The other option is to decide that pinning is "structural" for `field`,
//! meaning that if the struct is pinned then so is the field.
//!
//! This allows writing a projection that creates a <code>[Pin]<[`&mut Field`]></code>, thus
//! witnessing that the field is pinned:
//!
//! ```rust,no_run
//! # use std::pin::Pin;
//! # type Field = i32;
//! # struct Struct { field: Field }
//! impl Struct {
//!     fn field(self: Pin<&mut Self>) -> Pin<&mut Field> {
//!         // This is okay because `field` is pinned when `self` is.
//!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }
//!     }
//! }
//! ```
//!
//! For example, the `prev` and `succ` fields of a [`Node`]
//! are always either null or valid, so [`Node`] could provide a projection with
//! type <code>fn([Pin]<[`&mut Node`]>) -> [Pin]<[`&mut Node`]></code> for each
//! of them. These fields need to be structurally-pinned, since the outer [`List`]
//! assumes every [`Node`] in it is pinned.
//!
//! Structural pinning comes with a few extra requirements:
//!
//! 1.  *Structural [`Unpin`].* A struct can be [`Unpin`] if, and only if, all of its
//!     structurally-pinned fields are, too. This is [`Unpin`]'s behavior by default.
//!     However, as author, it is your responsibility to not write something like
//!     <code>unsafe impl\<T> [Unpin] for Struct\<T> {}</code>. (Adding *any* projection
//!     operation requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break
//!     the principle that you only have to worry about any of this if you use [`unsafe`].)
//!
//! 2.  *Pinned Destruction.* As discussed [above][drop-impl], [`drop`] takes
//!     [`&mut self`], but the struct (and hence its fields) might have been pinned
//!     before. The destructor must be written as if its argument was
//!     <code>self: [Pin]\<[`&mut Self`]></code>, instead.
//!
//!     As a consequence, the struct *must not* be [`#[repr(packed)]`][packed].
//!
//! 3.  *Structural Notice of Destruction.* You must uphold the the [`Drop` guarantee][drop-guarantee]:
//!     once your struct is pinned, the struct's storage cannot be re-used without calling the
//!     structurally-pinned fields' destructors, too.
//!
//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`]
//!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates
//!     the [`Drop` guarantee][drop-guarantee], because it can lead to elements being deallocated without
//!     their destructor being called.
//!
//!     [`VecDeque<T>`] has no pinning projections, so its destructor is sound. If it wanted
//!     to provide such structural pinning, its destructor would need to abort the process if any
//!     of the destructors panicked.
//!
//! 4.  You must not offer any other operations that could lead to data being *moved* out of
//!     the structural fields when your type is pinned. For example, if the struct contains an
//!     [`Option<T>`] and there is a [`take`][Option::take]-like operation with type
//!     <code>fn([Pin]<[&mut Struct\<T>][&mut]>) -> [`Option<T>`]</code>,
//!     then that operation can be used to move a `T` out of a pinned `Struct<T>` – which
//!     means pinning cannot be structural for the field holding this data.
//!
//!     For a more complex example of moving data out of a pinned type,
//!     imagine if [`RefCell<T>`] had a method
//!     <code>fn get_pin_mut(self: [Pin]<[`&mut Self`]>) -> [Pin]<[`&mut T`]></code>.
//!     Then we could do the following:
//!     ```compile_fail
//!     # use std::cell::RefCell;
//!     # use std::pin::Pin;
//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {
//!         // Here we get pinned access to the `T`.
//!         let _: Pin<&mut T> = rc.as_mut().get_pin_mut();
//!
//!         // And here we have `&mut T` to the same data.
//!         let shared: &RefCell<T> = rc.into_ref().get_ref();
//!         let borrow = shared.borrow_mut();
//!         let content = &mut *borrow;
//!     }
//!     ```
//!     This is catastrophic: it means we can first pin the content of the
//!     [`RefCell<T>`] (using <code>[RefCell]::get_pin_mut</code>) and then move that
//!     content using the mutable reference we got later.
//!
//! ### Structural Pinning examples
//!
//! For a type like [`Vec<T>`], both possibilities (structural pinning or not) make
//! sense. A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut`
//! methods to get pinned references to elements. However, it could *not* allow calling
//! [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally
//! pinned) contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also
//! move the contents.
//!
//! A [`Vec<T>`] without structural pinning could
//! <code>impl\<T> [Unpin] for [`Vec<T>`]</code>, because the contents are never pinned
//! and the [`Vec<T>`] itself is fine with being moved as well.
//! At that point pinning just has no effect on the vector at all.
//!
//! In the standard library, pointer types generally do not have structural pinning,
//! and thus they do not offer pinning projections. This is why <code>[`Box<T>`]: [Unpin]</code>
//! holds for all `T`. It makes sense to do this for pointer types, because moving the
//! [`Box<T>`] does not actually move the `T`: the [`Box<T>`] can be freely
//! movable (aka [`Unpin`]) even if the `T` is not. In fact, even <code>[Pin]<[`Box<T>`]></code> and
//! <code>[Pin]<[`&mut T`]></code> are always [`Unpin`] themselves, for the same reason:
//! their contents (the `T`) are pinned, but the pointers themselves can be moved without moving
//! the pinned data. For both [`Box<T>`] and <code>[Pin]<[`Box<T>`]></code>,
//! whether the content is pinned is entirely independent of whether the
//! pointer is pinned, meaning pinning is *not* structural.
//!
//! When implementing a [`Future`] combinator, you will usually need structural pinning
//! for the nested futures, as you need to get pinned references to them to call [`poll`].
//! But if your combinator contains any other data that does not need to be pinned,
//! you can make those fields not structural and hence freely access them with a
//! mutable reference even when you just have <code>[Pin]<[`&mut Self`]></code>
//! (such as in your own [`poll`] implementation).
//!
//! [Target]: Deref::Target "ops::Deref::Target"
//! [`drop`]: Drop::drop "ops::Drop::drop"
//! [`poll`]: Future::poll "future::Future::poll"
//!
//! <!-- These require `alloc`, but we're in `core`. -->
//! [`std::alloc`]: ../../std/alloc/index.html
//! [`Box<T>`]: ../../std/boxed/struct.Box.html
//! [`Rc<T>`]: ../../std/rc/struct.Rc.html
//! [`Vec<T>`]: ../../std/vec/struct.Vec.html
//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop
//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push
//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len
//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html
//!
//! [`&mut T`]: &mut
//! [`&mut self`]: &mut
//! [`&mut Self`]: &mut
//! [`&mut Field`]: &mut
//!
<<<<<<< HEAD
//! [Deref]: crate::ops::Deref "ops::Deref"
//! [`Deref`]: crate::ops::Deref "ops::Deref"
//! [Target]: crate::ops::Deref::Target "ops::Deref::Target"
//! [`DerefMut`]: crate::ops::DerefMut "ops::DerefMut"
//! [`mem::swap`]: crate::mem::swap "mem::swap"
//! [`mem::forget`]: crate::mem::forget "mem::forget"
//! [Vec]: ../../std/vec/struct.Vec.html "Vec"
//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len "Vec::set_len"
//! [Box]: ../../std/boxed/struct.Box.html "Box"
//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop "Vec::pop"
//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push "Vec::push"
//! [Rc]: ../../std/rc/struct.Rc.html "rc::Rc"
//! [RefCell]: crate::cell::RefCell "cell::RefCell"
//! [`drop`]: Drop::drop
//! [VecDeque]: ../../std/collections/struct.VecDeque.html "collections::VecDeque"
//! [`ptr::write`]: crate::ptr::write "ptr::write"
//! [`Future`]: crate::future::Future "future::Future"
//! [drop-impl]: #drop-implementation
//! [drop-guarantee]: #drop-guarantee
//! [`poll`]: crate::future::Future::poll "future::Future::poll"
//! [&]: reference "shared reference"
//! [&mut]: reference "mutable reference"
=======
>>>>>>> 389e1e2452d (Rewrite `Pin<P>` docs to clarify guarantees and uses)
//! [`unsafe`]: ../../std/keyword.unsafe.html "keyword unsafe"
//! [packed]: https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked

#![stable(feature = "pin", since = "1.33.0")]

use crate::cmp;
use crate::fmt;
use crate::hash::{Hash, Hasher};
use crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};

#[allow(unused_imports)]
use crate::{
    cell::{RefCell, UnsafeCell},
    future::Future,
    marker::PhantomPinned,
    mem, ptr,
};

/// A pinned pointer.
///
/// This is a wrapper around a kind of pointer which makes that pointer "pin" its
/// value in place, preventing the value referenced by that pointer from being moved
/// unless it implements [`Unpin`].
///
/// `Pin<P>` is guaranteed to have the same memory layout and ABI as `P`.
///
/// *See the [`pin` module] documentation for an explanation of pinning.*
///
/// [`pin` module]: self
//
// Note: the `Clone` derive below causes unsoundness as it's possible to implement
// `Clone` for mutable references.
// See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311> for more details.
#[stable(feature = "pin", since = "1.33.0")]
#[lang = "pin"]
#[fundamental]
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin<P> {
    // FIXME(#93176): this field is made `#[unstable] #[doc(hidden)] pub` to:
    //   - deter downstream users from accessing it (which would be unsound!),
    //   - let the `pin!` macro access it (such a macro requires using struct
    //     literal syntax in order to benefit from lifetime extension).
    // Long-term, `unsafe` fields or macro hygiene are expected to offer more robust alternatives.
    #[unstable(feature = "unsafe_pin_internals", issue = "none")]
    #[doc(hidden)]
    pub pointer: P,
}

// The following implementations aren't derived in order to avoid soundness
// issues. `&self.pointer` should not be accessible to untrusted trait
// implementations.
//
// See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311/73> for more details.

#[stable(feature = "pin_trait_impls", since = "1.41.0")]
impl<P: Deref, Q: Deref> PartialEq<Pin<Q>> for Pin<P>
where
    P::Target: PartialEq<Q::Target>,
{
    fn eq(&self, other: &Pin<Q>) -> bool {
        P::Target::eq(self, other)
    }

    fn ne(&self, other: &Pin<Q>) -> bool {
        P::Target::ne(self, other)
    }
}

#[stable(feature = "pin_trait_impls", since = "1.41.0")]
impl<P: Deref<Target: Eq>> Eq for Pin<P> {}

#[stable(feature = "pin_trait_impls", since = "1.41.0")]
impl<P: Deref, Q: Deref> PartialOrd<Pin<Q>> for Pin<P>
where
    P::Target: PartialOrd<Q::Target>,
{
    fn partial_cmp(&self, other: &Pin<Q>) -> Option<cmp::Ordering> {
        P::Target::partial_cmp(self, other)
    }

    fn lt(&self, other: &Pin<Q>) -> bool {
        P::Target::lt(self, other)
    }

    fn le(&self, other: &Pin<Q>) -> bool {
        P::Target::le(self, other)
    }

    fn gt(&self, other: &Pin<Q>) -> bool {
        P::Target::gt(self, other)
    }

    fn ge(&self, other: &Pin<Q>) -> bool {
        P::Target::ge(self, other)
    }
}

#[stable(feature = "pin_trait_impls", since = "1.41.0")]
impl<P: Deref<Target: Ord>> Ord for Pin<P> {
    fn cmp(&self, other: &Self) -> cmp::Ordering {
        P::Target::cmp(self, other)
    }
}

#[stable(feature = "pin_trait_impls", since = "1.41.0")]
impl<P: Deref<Target: Hash>> Hash for Pin<P> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        P::Target::hash(self, state);
    }
}

impl<P: Deref<Target: Unpin>> Pin<P> {
    /// Construct a new `Pin<P>` around a pointer to some data of a type that
    /// implements [`Unpin`].
    ///
    /// Unlike `Pin::new_unchecked`, this method is safe because the pointer
    /// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::pin::Pin;
    ///
    /// let mut val: u8 = 5;
    /// // We can pin the value, since it doesn't care about being moved
    /// let mut pinned: Pin<&mut u8> = Pin::new(&mut val);
    /// ```
    #[inline(always)]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    #[stable(feature = "pin", since = "1.33.0")]
    pub const fn new(pointer: P) -> Pin<P> {
        // SAFETY: the value pointed to is `Unpin`, and so has no requirements
        // around pinning.
        unsafe { Pin::new_unchecked(pointer) }
    }

    /// Unwraps this `Pin<P>` returning the underlying pointer.
    ///
    /// This requires that the data inside this `Pin` implements [`Unpin`] so that we
    /// can ignore the pinning invariants when unwrapping it.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::pin::Pin;
    ///
    /// let mut val: u8 = 5;
    /// let pinned: Pin<&mut u8> = Pin::new(&mut val);
    /// // Unwrap the pin to get a reference to the value
    /// let r = Pin::into_inner(pinned);
    /// assert_eq!(*r, 5);
    /// ```
    #[inline(always)]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    #[stable(feature = "pin_into_inner", since = "1.39.0")]
    pub const fn into_inner(pin: Pin<P>) -> P {
        pin.pointer
    }
}

impl<P: Deref> Pin<P> {
    /// Construct a new `Pin<P>` around a reference to some data of a type that
    /// may or may not implement `Unpin`.
    ///
    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used
    /// instead.
    ///
    /// # Safety
    ///
    /// This constructor is unsafe because we cannot guarantee that the data
    /// pointed to by `pointer` is pinned, meaning that the data will not be moved or
    /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does
    /// not guarantee that the data `P` points to is pinned, that is a violation of
    /// the API contract and may lead to undefined behavior in later (safe) operations.
    ///
    /// By using this method, you are making a promise about the `P::Deref` and
    /// `P::DerefMut` implementations, if they exist. Most importantly, they
    /// must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`
    /// will call `DerefMut::deref_mut` and `Deref::deref` *on the pinned pointer*
    /// and expect these methods to uphold the pinning invariants.
    /// Moreover, by calling this method you promise that the reference `P`
    /// dereferences to will not be moved out of again; in particular, it
    /// must not be possible to obtain a `&mut P::Target` and then
    /// move out of that reference (using, for example [`mem::swap`]).
    ///
    /// For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because
    /// while you are able to pin it for the given lifetime `'a`, you have no control
    /// over whether it is kept pinned once `'a` ends:
    /// ```
    /// use std::mem;
    /// use std::pin::Pin;
    ///
    /// fn move_pinned_ref<T>(mut a: T, mut b: T) {
    ///     unsafe {
    ///         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);
    ///         // This should mean the pointee `a` can never move again.
    ///     }
    ///     mem::swap(&mut a, &mut b); // Potential UB down the road ⚠️
    ///     // The address of `a` changed to `b`'s stack slot, so `a` got moved even
    ///     // though we have previously pinned it! We have violated the pinning API contract.
    /// }
    /// ```
    /// A value, once pinned, must remain pinned until it is dropped (unless its type implements
    /// `Unpin`). Because `Pin<&mut T>` does not own the value, dropping the `Pin` will not drop
    /// the value and will not end the pinning contract. So moving the value after dropping the
    /// `Pin<&mut T>` is still a violation of the API contract.
    ///
    /// Similarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be
    /// aliases to the same data that are not subject to the pinning restrictions:
    /// ```
    /// use std::rc::Rc;
    /// use std::pin::Pin;
    ///
    /// fn move_pinned_rc<T>(mut x: Rc<T>) {
    ///     let pinned = unsafe { Pin::new_unchecked(Rc::clone(&x)) };
    ///     {
    ///         let p: Pin<&T> = pinned.as_ref();
    ///         // This should mean the pointee can never move again.
    ///     }
    ///     drop(pinned);
    ///     let content = Rc::get_mut(&mut x).unwrap(); // Potential UB down the road ⚠️
    ///     // Now, if `x` was the only reference, we have a mutable reference to
    ///     // data that we pinned above, which we could use to move it as we have
    ///     // seen in the previous example. We have violated the pinning API contract.
    ///  }
    ///  ```
    ///
    /// ## Pinning of closure captures
    ///
    /// Particular care is required when using `Pin::new_unchecked` in a closure:
    /// `Pin::new_unchecked(&mut var)` where `var` is a by-value (moved) closure capture
    /// implicitly makes the promise that the closure itself is pinned, and that *all* uses
    /// of this closure capture respect that pinning.
    /// ```
    /// use std::pin::Pin;
    /// use std::task::Context;
    /// use std::future::Future;
    ///
    /// fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {
    ///     // Create a closure that moves `x`, and then internally uses it in a pinned way.
    ///     let mut closure = move || unsafe {
    ///         let _ignore = Pin::new_unchecked(&mut x).poll(cx);
    ///     };
    ///     // Call the closure, so the future can assume it has been pinned.
    ///     closure();
    ///     // Move the closure somewhere else. This also moves `x`!
    ///     let mut moved = closure;
    ///     // Calling it again means we polled the future from two different locations,
    ///     // violating the pinning API contract.
    ///     moved(); // Potential UB ⚠️
    /// }
    /// ```
    /// When passing a closure to another API, it might be moving the closure any time, so
    /// `Pin::new_unchecked` on closure captures may only be used if the API explicitly documents
    /// that the closure is pinned.
    ///
    /// The better alternative is to avoid all that trouble and do the pinning in the outer function
    /// instead (here using the [`pin!`][crate::pin::pin] macro):
    /// ```
    /// use std::pin::pin;
    /// use std::task::Context;
    /// use std::future::Future;
    ///
    /// fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {
    ///     let mut x = pin!(x);
    ///     // Create a closure that captures `x: Pin<&mut _>`, which is safe to move.
    ///     let mut closure = move || {
    ///         let _ignore = x.as_mut().poll(cx);
    ///     };
    ///     // Call the closure, so the future can assume it has been pinned.
    ///     closure();
    ///     // Move the closure somewhere else.
    ///     let mut moved = closure;
    ///     // Calling it again here is fine (except that we might be polling a future that already
    ///     // returned `Poll::Ready`, but that is a separate problem).
    ///     moved();
    /// }
    /// ```
    ///
    /// [`mem::swap`]: crate::mem::swap
    #[lang = "new_unchecked"]
    #[inline(always)]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    #[stable(feature = "pin", since = "1.33.0")]
    pub const unsafe fn new_unchecked(pointer: P) -> Pin<P> {
        Pin { pointer }
    }

    /// Gets a pinned shared reference from this pinned pointer.
    ///
    /// This is a generic method to go from `&Pin<Pointer<T>>` to `Pin<&T>`.
    /// It is safe because, as part of the contract of `Pin::new_unchecked`,
    /// the pointee cannot move after `Pin<Pointer<T>>` got created.
    /// "Malicious" implementations of `Pointer::Deref` are likewise
    /// ruled out by the contract of `Pin::new_unchecked`.
    #[stable(feature = "pin", since = "1.33.0")]
    #[inline(always)]
    pub fn as_ref(&self) -> Pin<&P::Target> {
        // SAFETY: see documentation on this function
        unsafe { Pin::new_unchecked(&*self.pointer) }
    }

    /// Unwraps this `Pin<P>` returning the underlying pointer.
    ///
    /// # Safety
    ///
    /// This function is unsafe. You must guarantee that you will continue to
    /// treat the pointer `P` as pinned after you call this function, so that
    /// the invariants on the `Pin` type can be upheld. If the code using the
    /// resulting `P` does not continue to maintain the pinning invariants that
    /// is a violation of the API contract and may lead to undefined behavior in
    /// later (safe) operations.
    ///
    /// If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used
    /// instead.
    #[inline(always)]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    #[stable(feature = "pin_into_inner", since = "1.39.0")]
    pub const unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {
        pin.pointer
    }
}

impl<P: DerefMut> Pin<P> {
    /// Gets a pinned mutable reference from this pinned pointer.
    ///
    /// This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.
    /// It is safe because, as part of the contract of `Pin::new_unchecked`,
    /// the pointee cannot move after `Pin<Pointer<T>>` got created.
    /// "Malicious" implementations of `Pointer::DerefMut` are likewise
    /// ruled out by the contract of `Pin::new_unchecked`.
    ///
    /// This method is useful when doing multiple calls to functions that consume the pinned type.
    ///
    /// # Example
    ///
    /// ```
    /// use std::pin::Pin;
    ///
    /// # struct Type {}
    /// impl Type {
    ///     fn method(self: Pin<&mut Self>) {
    ///         // do something
    ///     }
    ///
    ///     fn call_method_twice(mut self: Pin<&mut Self>) {
    ///         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.
    ///         self.as_mut().method();
    ///         self.as_mut().method();
    ///     }
    /// }
    /// ```
    #[stable(feature = "pin", since = "1.33.0")]
    #[inline(always)]
    pub fn as_mut(&mut self) -> Pin<&mut P::Target> {
        // SAFETY: see documentation on this function
        unsafe { Pin::new_unchecked(&mut *self.pointer) }
    }

    /// Assigns a new value to the memory behind the pinned reference.
    ///
    /// This overwrites pinned data, but that is okay: its destructor gets
    /// run before being overwritten, so no pinning guarantee is violated.
    ///
    /// # Example
    ///
    /// ```
    /// use std::pin::Pin;
    ///
    /// let mut val: u8 = 5;
    /// let mut pinned: Pin<&mut u8> = Pin::new(&mut val);
    /// println!("{}", pinned); // 5
    /// pinned.as_mut().set(10);
    /// println!("{}", pinned); // 10
    /// ```
    #[stable(feature = "pin", since = "1.33.0")]
    #[inline(always)]
    pub fn set(&mut self, value: P::Target)
    where
        P::Target: Sized,
    {
        *(self.pointer) = value;
    }
}

impl<'a, T: ?Sized> Pin<&'a T> {
    /// Constructs a new pin by mapping the interior value.
    ///
    /// For example, if you wanted to get a `Pin` of a field of something,
    /// you could use this to get access to that field in one line of code.
    /// However, there are several gotchas with these "pinning projections";
    /// see the [`pin` module] documentation for further details on that topic.
    ///
    /// # Safety
    ///
    /// This function is unsafe. You must guarantee that the data you return
    /// will not move so long as the argument value does not move (for example,
    /// because it is one of the fields of that value), and also that you do
    /// not move out of the argument you receive to the interior function.
    ///
    /// [`pin` module]: self#projections-and-structural-pinning
    #[stable(feature = "pin", since = "1.33.0")]
    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>
    where
        U: ?Sized,
        F: FnOnce(&T) -> &U,
    {
        let pointer = &*self.pointer;
        let new_pointer = func(pointer);

        // SAFETY: the safety contract for `new_unchecked` must be
        // upheld by the caller.
        unsafe { Pin::new_unchecked(new_pointer) }
    }

    /// Gets a shared reference out of a pin.
    ///
    /// This is safe because it is not possible to move out of a shared reference.
    /// It may seem like there is an issue here with interior mutability: in fact,
    /// it *is* possible to move a `T` out of a `&RefCell<T>`. However, this is
    /// not a problem as long as there does not also exist a `Pin<&T>` pointing
    /// to the same data, and `RefCell<T>` does not let you create a pinned reference
    /// to its contents. See the discussion on ["pinning projections"] for further
    /// details.
    ///
    /// Note: `Pin` also implements `Deref` to the target, which can be used
    /// to access the inner value. However, `Deref` only provides a reference
    /// that lives for as long as the borrow of the `Pin`, not the lifetime of
    /// the `Pin` itself. This method allows turning the `Pin` into a reference
    /// with the same lifetime as the original `Pin`.
    ///
    /// ["pinning projections"]: self#projections-and-structural-pinning
    #[inline(always)]
    #[must_use]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    #[stable(feature = "pin", since = "1.33.0")]
    pub const fn get_ref(self) -> &'a T {
        self.pointer
    }
}

impl<'a, T: ?Sized> Pin<&'a mut T> {
    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.
    #[inline(always)]
    #[must_use = "`self` will be dropped if the result is not used"]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    #[stable(feature = "pin", since = "1.33.0")]
    pub const fn into_ref(self) -> Pin<&'a T> {
        Pin { pointer: self.pointer }
    }

    /// Gets a mutable reference to the data inside of this `Pin`.
    ///
    /// This requires that the data inside this `Pin` is `Unpin`.
    ///
    /// Note: `Pin` also implements `DerefMut` to the data, which can be used
    /// to access the inner value. However, `DerefMut` only provides a reference
    /// that lives for as long as the borrow of the `Pin`, not the lifetime of
    /// the `Pin` itself. This method allows turning the `Pin` into a reference
    /// with the same lifetime as the original `Pin`.
    #[inline(always)]
    #[must_use = "`self` will be dropped if the result is not used"]
    #[stable(feature = "pin", since = "1.33.0")]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    pub const fn get_mut(self) -> &'a mut T
    where
        T: Unpin,
    {
        self.pointer
    }

    /// Gets a mutable reference to the data inside of this `Pin`.
    ///
    /// # Safety
    ///
    /// This function is unsafe. You must guarantee that you will never move
    /// the data out of the mutable reference you receive when you call this
    /// function, so that the invariants on the `Pin` type can be upheld.
    ///
    /// If the underlying data is `Unpin`, `Pin::get_mut` should be used
    /// instead.
    #[inline(always)]
    #[must_use = "`self` will be dropped if the result is not used"]
    #[stable(feature = "pin", since = "1.33.0")]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    pub const unsafe fn get_unchecked_mut(self) -> &'a mut T {
        self.pointer
    }

    /// Construct a new pin by mapping the interior value.
    ///
    /// For example, if you wanted to get a `Pin` of a field of something,
    /// you could use this to get access to that field in one line of code.
    /// However, there are several gotchas with these "pinning projections";
    /// see the [`pin` module] documentation for further details on that topic.
    ///
    /// # Safety
    ///
    /// This function is unsafe. You must guarantee that the data you return
    /// will not move so long as the argument value does not move (for example,
    /// because it is one of the fields of that value), and also that you do
    /// not move out of the argument you receive to the interior function.
    ///
    /// [`pin` module]: self#projections-and-structural-pinning
    #[must_use = "`self` will be dropped if the result is not used"]
    #[stable(feature = "pin", since = "1.33.0")]
    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>
    where
        U: ?Sized,
        F: FnOnce(&mut T) -> &mut U,
    {
        // SAFETY: the caller is responsible for not moving the
        // value out of this reference.
        let pointer = unsafe { Pin::get_unchecked_mut(self) };
        let new_pointer = func(pointer);
        // SAFETY: as the value of `this` is guaranteed to not have
        // been moved out, this call to `new_unchecked` is safe.
        unsafe { Pin::new_unchecked(new_pointer) }
    }
}

impl<T: ?Sized> Pin<&'static T> {
    /// Get a pinned reference from a static reference.
    ///
    /// This is safe, because `T` is borrowed for the `'static` lifetime, which
    /// never ends.
    #[stable(feature = "pin_static_ref", since = "1.61.0")]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    pub const fn static_ref(r: &'static T) -> Pin<&'static T> {
        // SAFETY: The 'static borrow guarantees the data will not be
        // moved/invalidated until it gets dropped (which is never).
        unsafe { Pin::new_unchecked(r) }
    }
}

impl<'a, P: DerefMut> Pin<&'a mut Pin<P>> {
    /// Gets a pinned mutable reference from this nested pinned pointer.
    ///
    /// This is a generic method to go from `Pin<&mut Pin<Pointer<T>>>` to `Pin<&mut T>`. It is
    /// safe because the existence of a `Pin<Pointer<T>>` ensures that the pointee, `T`, cannot
    /// move in the future, and this method does not enable the pointee to move. "Malicious"
    /// implementations of `P::DerefMut` are likewise ruled out by the contract of
    /// `Pin::new_unchecked`.
    #[unstable(feature = "pin_deref_mut", issue = "86918")]
    #[must_use = "`self` will be dropped if the result is not used"]
    #[inline(always)]
    pub fn as_deref_mut(self) -> Pin<&'a mut P::Target> {
        // SAFETY: What we're asserting here is that going from
        //
        //     Pin<&mut Pin<P>>
        //
        // to
        //
        //     Pin<&mut P::Target>
        //
        // is safe.
        //
        // We need to ensure that two things hold for that to be the case:
        //
        // 1) Once we give out a `Pin<&mut P::Target>`, an `&mut P::Target` will not be given out.
        // 2) By giving out a `Pin<&mut P::Target>`, we do not risk of violating `Pin<&mut Pin<P>>`
        //
        // The existence of `Pin<P>` is sufficient to guarantee #1: since we already have a
        // `Pin<P>`, it must already uphold the pinning guarantees, which must mean that
        // `Pin<&mut P::Target>` does as well, since `Pin::as_mut` is safe. We do not have to rely
        // on the fact that P is _also_ pinned.
        //
        // For #2, we need to ensure that code given a `Pin<&mut P::Target>` cannot cause the
        // `Pin<P>` to move? That is not possible, since `Pin<&mut P::Target>` no longer retains
        // any access to the `P` itself, much less the `Pin<P>`.
        unsafe { self.get_unchecked_mut() }.as_mut()
    }
}

impl<T: ?Sized> Pin<&'static mut T> {
    /// Get a pinned mutable reference from a static mutable reference.
    ///
    /// This is safe, because `T` is borrowed for the `'static` lifetime, which
    /// never ends.
    #[stable(feature = "pin_static_ref", since = "1.61.0")]
    #[rustc_const_unstable(feature = "const_pin", issue = "76654")]
    pub const fn static_mut(r: &'static mut T) -> Pin<&'static mut T> {
        // SAFETY: The 'static borrow guarantees the data will not be
        // moved/invalidated until it gets dropped (which is never).
        unsafe { Pin::new_unchecked(r) }
    }
}

#[stable(feature = "pin", since = "1.33.0")]
impl<P: Deref> Deref for Pin<P> {
    type Target = P::Target;
    fn deref(&self) -> &P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

#[stable(feature = "pin", since = "1.33.0")]
impl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {
    fn deref_mut(&mut self) -> &mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}

#[unstable(feature = "receiver_trait", issue = "none")]
impl<P: Receiver> Receiver for Pin<P> {}

#[stable(feature = "pin", since = "1.33.0")]
impl<P: fmt::Debug> fmt::Debug for Pin<P> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.pointer, f)
    }
}

#[stable(feature = "pin", since = "1.33.0")]
impl<P: fmt::Display> fmt::Display for Pin<P> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&self.pointer, f)
    }
}

#[stable(feature = "pin", since = "1.33.0")]
impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Pointer::fmt(&self.pointer, f)
    }
}

// Note: this means that any impl of `CoerceUnsized` that allows coercing from
// a type that impls `Deref<Target=impl !Unpin>` to a type that impls
// `Deref<Target=Unpin>` is unsound. Any such impl would probably be unsound
// for other reasons, though, so we just need to take care not to allow such
// impls to land in std.
#[stable(feature = "pin", since = "1.33.0")]
impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}

#[stable(feature = "pin", since = "1.33.0")]
impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}

/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning a `value: T` locally.
///
/// Unlike [`Box::pin`], this does not create a new heap allocation. As explained
/// below, the element might still end up on the heap however.
///
/// The local pinning performed by this macro is usually dubbed "stack"-pinning.
/// Outside of `async` contexts locals do indeed get stored on the stack. In
/// `async` functions or blocks however, any locals crossing an `.await` point
/// are part of the state captured by the `Future`, and will use the storage of
/// those. That storage can either be on the heap or on the stack. Therefore,
/// local pinning is a more accurate term.
///
/// If the type of the given value does not implement [`Unpin`], then this macro
/// pins the value in memory in a way that prevents moves. On the other hand,
/// if the type does implement [`Unpin`], <code>[Pin]<[&mut] T></code> behaves
/// like <code>[&mut] T</code>, and operations such as
/// [`mem::replace()`][crate::mem::replace] or [`mem::take()`](crate::mem::take)
/// will allow moves of the value.
/// See [the `Unpin` section of the `pin` module][self#unpin] for details.
///
/// ## Examples
///
/// ### Basic usage
///
/// ```rust
/// # use core::marker::PhantomPinned as Foo;
/// use core::pin::{pin, Pin};
///
/// fn stuff(foo: Pin<&mut Foo>) {
///     // …
///     # let _ = foo;
/// }
///
/// let pinned_foo = pin!(Foo { /* … */ });
/// stuff(pinned_foo);
/// // or, directly:
/// stuff(pin!(Foo { /* … */ }));
/// ```
///
/// ### Manually polling a `Future` (without `Unpin` bounds)
///
/// ```rust
/// use std::{
///     future::Future,
///     pin::pin,
///     task::{Context, Poll},
///     thread,
/// };
/// # use std::{sync::Arc, task::Wake, thread::Thread};
///
/// # /// A waker that wakes up the current thread when called.
/// # struct ThreadWaker(Thread);
/// #
/// # impl Wake for ThreadWaker {
/// #     fn wake(self: Arc<Self>) {
/// #         self.0.unpark();
/// #     }
/// # }
/// #
/// /// Runs a future to completion.
/// fn block_on<Fut: Future>(fut: Fut) -> Fut::Output {
///     let waker_that_unparks_thread = // …
///         # Arc::new(ThreadWaker(thread::current())).into();
///     let mut cx = Context::from_waker(&waker_that_unparks_thread);
///     // Pin the future so it can be polled.
///     let mut pinned_fut = pin!(fut);
///     loop {
///         match pinned_fut.as_mut().poll(&mut cx) {
///             Poll::Pending => thread::park(),
///             Poll::Ready(res) => return res,
///         }
///     }
/// }
/// #
/// # assert_eq!(42, block_on(async { 42 }));
/// ```
///
/// ### With `Coroutine`s
///
/// ```rust
/// #![feature(coroutines)]
/// #![feature(coroutine_trait)]
/// use core::{
///     ops::{Coroutine, CoroutineState},
///     pin::pin,
/// };
///
/// fn coroutine_fn() -> impl Coroutine<Yield = usize, Return = ()> /* not Unpin */ {
///  // Allow coroutine to be self-referential (not `Unpin`)
///  // vvvvvv        so that locals can cross yield points.
///     static || {
///         let foo = String::from("foo");
///         let foo_ref = &foo; // ------+
///         yield 0;                  // | <- crosses yield point!
///         println!("{foo_ref}"); // <--+
///         yield foo.len();
///     }
/// }
///
/// fn main() {
///     let mut coroutine = pin!(coroutine_fn());
///     match coroutine.as_mut().resume(()) {
///         CoroutineState::Yielded(0) => {},
///         _ => unreachable!(),
///     }
///     match coroutine.as_mut().resume(()) {
///         CoroutineState::Yielded(3) => {},
///         _ => unreachable!(),
///     }
///     match coroutine.resume(()) {
///         CoroutineState::Yielded(_) => unreachable!(),
///         CoroutineState::Complete(()) => {},
///     }
/// }
/// ```
///
/// ## Remarks
///
/// Precisely because a value is pinned to local storage, the resulting <code>[Pin]<[&mut] T></code>
/// reference ends up borrowing a local tied to that block: it can't escape it.
///
/// The following, for instance, fails to compile:
///
/// ```rust,compile_fail
/// use core::pin::{pin, Pin};
/// # use core::{marker::PhantomPinned as Foo, mem::drop as stuff};
///
/// let x: Pin<&mut Foo> = {
///     let x: Pin<&mut Foo> = pin!(Foo { /* … */ });
///     x
/// }; // <- Foo is dropped
/// stuff(x); // Error: use of dropped value
/// ```
///
/// <details><summary>Error message</summary>
///
/// ```console
/// error[E0716]: temporary value dropped while borrowed
///   --> src/main.rs:9:28
///    |
/// 8  | let x: Pin<&mut Foo> = {
///    |     - borrow later stored here
/// 9  |     let x: Pin<&mut Foo> = pin!(Foo { /* … */ });
///    |                            ^^^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
/// 10 |     x
/// 11 | }; // <- Foo is dropped
///    | - temporary value is freed at the end of this statement
///    |
///    = note: consider using a `let` binding to create a longer lived value
/// ```
///
/// </details>
///
/// This makes [`pin!`] **unsuitable to pin values when intending to _return_ them**. Instead, the
/// value is expected to be passed around _unpinned_ until the point where it is to be consumed,
/// where it is then useful and even sensible to pin the value locally using [`pin!`].
///
/// If you really need to return a pinned value, consider using [`Box::pin`] instead.
///
/// On the other hand, local pinning using [`pin!`] is likely to be cheaper than
/// pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not
/// requiring an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]
/// constructor.
///
/// [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin
#[stable(feature = "pin_macro", since = "1.68.0")]
#[rustc_macro_transparency = "semitransparent"]
#[allow_internal_unstable(unsafe_pin_internals)]
pub macro pin($value:expr $(,)?) {
    // This is `Pin::new_unchecked(&mut { $value })`, so, for starters, let's
    // review such a hypothetical macro (that any user-code could define):
    //
    // ```rust
    // macro_rules! pin {( $value:expr ) => (
    //     match &mut { $value } { at_value => unsafe { // Do not wrap `$value` in an `unsafe` block.
    //         $crate::pin::Pin::<&mut _>::new_unchecked(at_value)
    //     }}
    // )}
    // ```
    //
    // Safety:
    //   - `type P = &mut _`. There are thus no pathological `Deref{,Mut}` impls
    //     that would break `Pin`'s invariants.
    //   - `{ $value }` is braced, making it a _block expression_, thus **moving**
    //     the given `$value`, and making it _become an **anonymous** temporary_.
    //     By virtue of being anonymous, it can no longer be accessed, thus
    //     preventing any attempts to `mem::replace` it or `mem::forget` it, _etc._
    //
    // This gives us a `pin!` definition that is sound, and which works, but only
    // in certain scenarios:
    //   - If the `pin!(value)` expression is _directly_ fed to a function call:
    //     `let poll = pin!(fut).poll(cx);`
    //   - If the `pin!(value)` expression is part of a scrutinee:
    //     ```rust
    //     match pin!(fut) { pinned_fut => {
    //         pinned_fut.as_mut().poll(...);
    //         pinned_fut.as_mut().poll(...);
    //     }} // <- `fut` is dropped here.
    //     ```
    // Alas, it doesn't work for the more straight-forward use-case: `let` bindings.
    // ```rust
    // let pinned_fut = pin!(fut); // <- temporary value is freed at the end of this statement
    // pinned_fut.poll(...) // error[E0716]: temporary value dropped while borrowed
    //                      // note: consider using a `let` binding to create a longer lived value
    // ```
    //   - Issues such as this one are the ones motivating https://github.com/rust-lang/rfcs/pull/66
    //
    // This makes such a macro incredibly unergonomic in practice, and the reason most macros
    // out there had to take the path of being a statement/binding macro (_e.g._, `pin!(future);`)
    // instead of featuring the more intuitive ergonomics of an expression macro.
    //
    // Luckily, there is a way to avoid the problem. Indeed, the problem stems from the fact that a
    // temporary is dropped at the end of its enclosing statement when it is part of the parameters
    // given to function call, which has precisely been the case with our `Pin::new_unchecked()`!
    // For instance,
    // ```rust
    // let p = Pin::new_unchecked(&mut <temporary>);
    // ```
    // becomes:
    // ```rust
    // let p = { let mut anon = <temporary>; &mut anon };
    // ```
    //
    // However, when using a literal braced struct to construct the value, references to temporaries
    // can then be taken. This makes Rust change the lifespan of such temporaries so that they are,
    // instead, dropped _at the end of the enscoping block_.
    // For instance,
    // ```rust
    // let p = Pin { pointer: &mut <temporary> };
    // ```
    // becomes:
    // ```rust
    // let mut anon = <temporary>;
    // let p = Pin { pointer: &mut anon };
    // ```
    // which is *exactly* what we want.
    //
    // See https://doc.rust-lang.org/1.58.1/reference/destructors.html#temporary-lifetime-extension
    // for more info.
    $crate::pin::Pin::<&mut _> { pointer: &mut { $value } }
}
